pub_date	title	venue	excerpt	citation	url_slug	paper_url
2020-01-01	Property-based Testing for LG Home Appliances using Accelerated Software-in-the-Loop Simulation	International Conference on Software Engineering - Software Engineering in Practice (ICSE-SEIP) 2020	TBD	.	property-based-testing	TBD
2020-02-15	Manifold-based Test Generation for Image Classifiers	IEEE International Conference on Artificial Intelligence Testing (AITest) 2020	"Neural networks used for image classification tasks in critical applications must be tested with sufficient realistic data to assure their correctness. To effectively test an image classification neural network, one must obtain realistic test data adequate enough to inspire confidence that differences between the implicit requirements and the learned model would be exposed. This raises two challenges: first, an adequate subset of the data points must be carefully chosen to inspire confidence, and second, the implicit requirements must be meaningfully extrapolated to data points beyond those in the explicit training set. This paper proposes a novel framework to address these challenges. Our approach is based on the premise that patterns in a large input data space can be effectively captured in a smaller manifold space, from which similar yet novel test cases---both the input and the label---can be sampled and generated. A variant of Conditional Variational Autoencoder (CVAE) is used for capturing this manifold with a generative function, and a search technique is applied on this manifold space to efficiently find fault-revealing inputs. Experiments show that this approach enables generation of thousands of realistic yet fault-revealing test cases efficiently even for well-trained models."	.	manifold-based-test	https://arxiv.org/pdf/2002.06337.pdf
2020-02-08	Manifold for machine learning assurance	International Conference on Software Engineering - New Ideas and Emerging Results (ICSE-NIER) 2020	"The increasing use of machine-learning (ML) enabled systems in critical tasks fuels the quest for novel verification and validation techniques yet grounded in accepted system assurance principles. In traditional system development, model-based techniques have been widely adopted, where the central premise is that abstract models of the required system provide a sound basis for judging its implementation. We posit an analogous approach for ML systems using an ML technique that extracts from the high-dimensional training data implicitly describing the required system, a low-dimensional underlying structure--a manifold. It is then harnessed for a range of quality assurance tasks such as test adequacy measurement, test input generation, and runtime monitoring of the target ML system. The approach is built on variational autoencoder, an unsupervised method for learning a pair of mutually near-inverse functions between a given high-dimensional dataset and a low-dimensional representation. Preliminary experiments establish that the proposed manifold-based approach, for test adequacy drives diversity in test data, for test generation yields fault-revealing yet realistic test cases, and for runtime monitoring provides an independent means to assess trustability of the target system's output."	.	manifold-for-ml	https://arxiv.org/pdf/2002.03147.pdf
2019-04-04	Input prioritization for testing neural networks	IEEE International Conference on Artificial Intelligence Testing (AITest) 2019	"Deep neural networks (DNNs) are increasingly being adopted for sensing and control functions in a variety of safety and mission-critical systems such as self-driving cars, autonomous air vehicles, medical diagnostics and industrial robotics. Failures of such systems can lead to loss of life or property, which necessitates stringent verification and validation for providing high assurance. Though formal verification approaches are being investigated, testing remains the primary technique for assessing the dependability of such systems. Due to the nature of the tasks handled by DNNs, the cost of obtaining test oracle data—the expected output, a.k.a. label, for a given input—is high, which significantly impacts the amount and quality of testing that can be performed. Thus, prioritizing input data for testing DNNs in meaningful ways to reduce the cost of labeling can go a long way in increasing testing efficacy. This paper proposes using gauges of the DNN's sentiment derived from the computation performed by the model, as a means to identify inputs that are likely to reveal weaknesses. We empirically assessed the efficacy of three such sentiment measures for prioritization-confidence, uncertainty and surprise-and compare their effectiveness in terms of their fault-revealing capability and retraining effectiveness. The results indicate that sentiment measures can effectively flag inputs that expose unacceptable DNN behavior. For MNIST models, the average percentage of inputs correctly flagged ranged from 88% to 94.8%."	.	input-prioritization	https://ieeexplore.ieee.org/abstract/document/8718224
2019-02-24	Binary Mutation Analysis of Tests Using Reassembleable Disassembly	Workshop on Binary Analysis Research (BAR) 2019	"Good tests are important in software development, but it can be hard to tell whether tests will reveal future faults that are themselves unknown. Mutation analysis, which checks whether tests reveal inserted changes in a program, is a strong measure of test suite adequacy, but common source-or compilerlevel approaches to mutation testing are not applicable to software available only in binary form. We explore mutation analysis as an application of the reassembleable disassembly approach to binary rewriting, building a tool for x86 binaries on top of the previously-developed Uroboros system, and apply it to the C benchmarks from SPEC CPU 2006 and to five examples of embedded control software. The results demonstrate that our approach works effectively across these software domains: as expected, tests designed for performance benchmarking reveal fewer mutants than tests generated to achieve high code coverage, but mutation scores indicate differences in test origins and features such as code size and fault-tolerance. Our binary-level tool also achieves comparable results to source-level mutation analysis despite supporting a more limited set of mutation operators. More generally we also argue that our experience shows how reassembleable disassembly is a valuable approach for constructing novel binary rewriting tools."	.	binary-mutation	https://ruoyuwang.me/bar2019/pdfs/bar2019-final58.pdf
2018-11-09	Contract discovery from black-box components	Proceedings of the 1st ACM SIGSOFT International Workshop on Automated Specification Inference	"Complex computer-controlled systems are commonly constructed in a middle-out fashion where existing subsystems and available components have a significant influence on system architecture and drive design decisions. During system design, the architect must verify that the components, put together as specified in the architecture, will achieve the desired system behavior. This typically leads to further design modifications or adjustments to requirements triggering another iteration of the design-verify cycle. For software components that are acquired from third-parties, often the only definitive source of information about the component's system-relevant behavior--its contract--is its object code. We posit that existing static and dynamic analysis techniques can be used to discover contracts that can help the system designer and specifically discuss how symbolic execution of object code may be particularly well-suited for this purpose."	.	contract-discovery	https://dl.acm.org/doi/abs/10.1145/3278177.3278179
2017-10-23	Toward rigorous object-code coverage criteria	2017 IEEE 28th International Symposium on Software Reliability Engineering (ISSRE)	"Object-branch coverage (OBC) is often used as a measure of the thoroughness of tests suites, augmenting or substituting source-code based structural criteria such as branch coverage and modified condition/decision coverage (MC/DC). In addition, with the increasing use of third-party components for which source-code access may be unavailable, robust object-code coverage criteria are essential to assess how well the components are exercised during testing. While OBC has the advantage of being programming language independent and is amenable to non-intrusive coverage measurement techniques, variations in compilers and the optimizations they perform can substantially change the structure of the generated code and the instructions used to represent branches. To address the need for a robust object coverage criterion, this paper proposes a rigorous definition of OBC such that it captures well the semantics of source code branches for a given instruction set architecture. We report an empirical assessment of these criteria for the Intel x86 instruction set on several examples from embedded control systems software. Preliminary results indicate that object-code coverage can be made robust to compilation variations and is comparable in its bug-finding efficacy to source level MC/DC."	.	towards-rigorous	https://ieeexplore.ieee.org/abstract/document/8109098
2017-07-01	Discovering instructions for robust binary-level coverage criteria	TECPS 2017: Proceedings of the 1st ACM SIGSOFT International Workshop on Testing Embedded and Cyber-Physical Systems	"Object-Branch Coverage (OBC) is often used to measure effectiveness of test suites, when source code is unavailable. The traditional OBC definition can be made more resilient to variations in compilers and the structure of generated code by creating more robust definitions. However finding which instructions should be included in each new definition is laborious, error-prone, and architecture-dependent. We automate the discovery of instructions to be included for an improved OBC definition on the X86 and ARM architectures. We discover all possible valid instructions by symbolically executing instruction decoders for X86 and ARM instructions. For each discovered instruction, we translate it to Vine IR, and check if the Vine IR translation satisfies the OBC definition. We verify the correctness of our tool by comparing its output with the X86 and ARM architecture manuals. Our automated instruction classification facilitates development of more robust OBC definitions with better bug-finding ability and lesser sensitivity to compiler variations."	.	discovering-instructions	https://dl.acm.org/doi/pdf/10.1145/3107091.3107092
2017-02-01	Constraint-based test generation for automotive operating systems	Software & Systems Modeling	"This work suggests a method for systematically constructing a software-level environment model for safety checking automotive operating systems by introducing a constraint specification language, OSEK_CSL. OSEK_CSL is designed to specify the usage constraints of automotive operating systems using a pre-defined set of constraint types identified from the international standard OSEK/VDX. Each constraint specified in OSEK_CSL is interpreted as either a regular language or a context-free language that can be checked by a finite automaton or a pushdown automaton. The set of usage constraints is used to systematically classify the universal usage model of OSEK-/VDX-based operating systems and to generate test sequences with varying degrees of constraint satisfaction using LTL model checking. With pre-defined constraint patterns and the full support of automation, test engineers can choose the degree of constraint satisfaction and generate test cases using combinatorial intersections of selected constraints that cover all corner cases classified by constraints. A series of experiments on an open-source automotive operating system show that our approach finds safety issues more effectively than conventional specification-based testing, scenario-based testing, and conformance testing."	.	constraint-based-test	https://link.springer.com/article/10.1007/s10270-014-0449-6
2015-06-01	Efficient safety checking for automotive operating systems using property-based slicing and constraint-based environment generation	Science of Computer Programming	"An automotive operating system is a safety-critical system that has a critical impact on the safety of road vehicles. Safety verification is a must in each stage of software development in such a system, but most existing work focuses on specification-level or model-level safety verification. This work proposes a collaborative approach using model checking and testing for the efficient safety checking of an automotive operating system. Efficiency is achieved through property-based slicing, which reduces the complexity of verification, and guided test sequence generation, which limits the input space to a set of representative test sequences selected from legal as well as illegal input spaces. Comprehensiveness is achieved by formally specifying external constraints using constraint automata from which guided test sequences are selected. The approach is implemented as a prototype tool set applied to the verification of an open source automotive operating system based on the OSEK/VDX international standard. The approach revealed several safety issues that could not be identified by existing approaches."	.	efficient-safety-checking	https://www.sciencedirect.com/science/article/pii/S0167642314004766
2015-04-13	Automated system-level safety testing using constraint patterns for automotive operating systems	Proceedings of the 30th Annual ACM Symposium on Applied Computing	"The automotive operating system is a typical safety-critical system that is tightly coupled with the operational environment through system services. However, existing automated techniques come short of testing the interface of such operating systems. We introduced an automated test generation method for system-level safety testing of the automotive operating systems, by utilizing the operational constraints defined in the specification. This work extends the idea by adding configuration-dependent and state-dependent constraint patterns, and by developing a tool chain to automate the constraint-based system-level testing. The effectiveness of our approach is demonstrated through a series of experiments, and a comparative analysis is performed between our method and concolic testing."	.	automated-system-level	https://dl.acm.org/doi/pdf/10.1145/2695664.2695935
2013-01-01	Property-based code slicing for efficient verification of osek/vdx operating systems	In Proceedings FTSCS 2012	"Testing is a de-facto verification technique in industry, but insufficient for identifying subtle issues due to its optimistic incompleteness. On the other hand, model checking is a powerful technique that supports comprehensiveness, and is thus suitable for the verification of safety-critical systems. However, it generally requires more knowledge and cost more than testing. This work attempts to take advantage of both techniques to achieve integrated and efficient verification of OSEK/VDX-based automotive operating systems. We propose property-based environment generation and model extraction techniques using static code analysis, which can be applied to both model checking and testing. The technique is automated and applied to an OSEK/VDX-based automotive operating system, Trampoline. Comparative experiments using random testing and model checking for the verification of assertions in the Trampoline kernel code show how our environment generation and abstraction approach can be utilized for efficient fault-detection."	.	property-based	https://arxiv.org/abs/1301.0042